Проверять задачи
http://dkab.github.io/jasmine-tests/

1. Напиши функцию создания генератора sequence(start, step).
Она при вызове возвращает другую функцию-генератор, которая при каждом вызове дает число на 1 больше,
и так до бесконечности. Начальное число, с которого начинать отсчет, и шаг, задается при создании генератора.
Шаг можно не указывать, тогда он будет равен одному. Начальное значение по умолчанию равно 0.
Генераторов можно создать сколько угодно.

var generator = sequence(10, 3);
var generator2 = sequence(7, 1);

console.log(generator()); // 10
console.log(generator()); // 13

console.log(generator2()); // 7

console.log(generator()); // 16

console.log(generator2()); // 8



2. Также, нужна функция take(gen, x) которая вызвает функцию gen заданное число (x) раз и
возвращает массив с результатами вызовов.

var gen2 = sequence(0, 2);
console.log(take(gen2, 5)); // [0, 2, 4, 6, 8 ]



3. Напиши функцию map(fn, array), которая принимает на вход функцию и массив,
и обрабатывает каждый элемент массива этой функцией, возвращая новый массив. Пример:

function square(x) { return x * x; } // возведение в квадрат
console.log(map(square, [1, 2, 3, 4])); // [1, 4, 9, 16]
console.log(map(square, [])); // []

Обрати внимание: функция не должна изменять переданный ей массив:

var arr = [1, 2, 3];
console.log(map(square, arr)); // [1, 4, 9]
console.log(arr); // [1, 2, 3]

4. Напиши функцию fmap(a, gen), которая принимает на вход 2 функции,
a и gen, где gen — функция-генератор вроде той, что была в первом задании.
fmap возвращает новую функцию-генератор, которая при каждом вызове берет следующее значение из gen и
 пропускает его через функцию a. Пример:

var gen = sequence(1, 1);
function square(x) { return x * x; }
var squareGen = fmap(square, gen);

console.log(squareGen()); // 1
console.log(squareGen()); // 4
console.log(squareGen()); // 9
console.log(squareGen()); // 16

Еще сделай тогда, чтобы в качестве gen можно было указать функцию с аргументами,
и при вызове эти аргументы бы передавались функции gen. Аргументов может быть любое количество.

function add(a, b) {
    return a + b;
}

// Мы получаем новую функцию, которая вызвает add, и результат пропускает через функцию square
var squareAdd = fmap(square, add);
console.log(squareAdd(2, 3)); // 25 = (2 + 3) ^ 2
console.log(squareAdd(5, 7)); // 144 = (5 + 7) ^ 2



5. Частичное применение (partial application)

Напиши функцию partial(fn, a1, a2, ....), которая позволяет зафиксировать
один или несколько аргументов функции. Пример:

function add(a, b) { return a + b; }
function mult(a, b, c, d) { return a * b * c * d; }

var add5 = partial(add, 5); // Мы получили функцию с 1 аргументом, которая прибавляет к любому числу 5

console.log(add5(2)); // 7
console.log(add5(10)); // 15
console.log(add5(8)); // 13

var mult23 = partial(mult, 2, 3); // мы зафиксировали первые 2 аргумента mult() как 2 и 3

console.log(mult23(4, 5)); // 2*3*4*5 = 120
console.log(mult23(1, 1)); // 2*3*1*1 = 6
Есть функция с аргументами:

f1(a, d, c, d)
Мы можем с помощью partial сделать из нее функцию с меньшим числом аргументов,
заранее задав значения для нескольких из них, например:

var f2 = partial(f1, 1, 2); // фиксируем a = 1, b = 2
И вызов:

f2(x, y)
будет равносилен вызову:

f1(1, 2, x, y)
Кстати, имеющийся в  JS метод bind() тоже может делать частичное применение:
http://frontender.info/partial-application-in-javascript-using-bind/
Но ты должен обойтись без его использования, и написать свой велосипед.


6. Наша функция partial позволяет фиксировать только первые аргументы.
Усовершенствуй ее, чтобы зафиксировать можно было любые аргументы,
пропущенные аргументы обозначаются с помощью undefined.
Обрати внимание, что теперь мы переименовали ее в partialAny, чтобы не путать с предыдущей:

function test(a, b, c) { return 'a=' + a + ',b=' + b + ',c=' + c; }
var test1_3 = partialAny(test, 1, undefined, 3);
console.log(test1_3(5)); // a=1,b=5,c=3


7. Напиши функцию bind, которая позволяет привязать контекст (значение this) к функции:

window.x = 1;
var ctx = { x: 2 };

function testThis(a) { console.log("x=" + this.x + ", a=" + a); }
console.log(testThis(100)); // x=1, a=100
var boundFunction = bind(testThis, ctx);
console.log(boundFunction(100)); // x=2, a= 100


8. Напиши функцию pluck, которая берет массив объектов и возвращает массив значений определенного поля:

var characters = [
  { 'name': 'barney', 'age': 36 },
  { 'name': 'fred', 'age': 40 }
];

console.log(pluck(characters, 'name')); // ['barney', 'fred']


9. Напиши функцию filter, которая принимает функцию-предикат и массив.
Возвращает она массив значений, для которых предикат вернет true.

var input = [1, 2, 3, 4, 5, 6];
function isEven(x) { return x % 2 == 0; } // проверяет на четность
console.log(filter(input, isEven)); // [2, 4, 6]
Функция не должна изменять исходный массив:
console.log(input); // [1, 2, 3, 4, 5, 6]


10. Напиши функцию, считающую число свойств в объекте:

var a = { a: 1, b: 2 };
console.log(count(a)); // 2
var b = function () {};
console.log(count(b)); // 0
var c = [1, 2, 3];
console.log(count(c)); // 3
var d = [];
d[100] = 1;
console.log(count(d)); // 1
Кстати, в новых браузерах с поддержкой Javascript ES5 есть метод Object.keys(x),
возвращающий массив ключей у объекта.


11. Дан список вида «страна, город, население»:
http://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BC%D1%8B%D0%B5_%D0%BD%D0%B0%D1%81%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D0%B5_%D0%B0%D0%B3%D0%BB%D0%BE%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B

Можешь взять оттуда первые 5-10 городов и перенести в код.
Города в списке могут идти в произвольном порядке. Напиши программу, которая отберет и выведет N самых населенных городов по убыванию числа жителей.


СУПЕР СЛОЖНЫЕ!!!!!!!

12. Напиши функцию неглубокого копирования объектов и массивов.

По умолчанию, как ты наверно, знаешь, при копировании объектов или массивов
(которые являются объекты) мы копируем лишь ссылку на тот же самый объект:

var a = [1, 2, 3];
var b = a; // b указывает на тот же массив
b.push(4);
console.log(a); // [1, 2, 3, 4]
Функция неглубокого копирования должна создавать новый массив/объект,
и копировать в него элементы из старого. При этом сами элементы копируются по ссылке:

var a = { x: 1, y: 2, z: [1, 2, 3] };
var b = shallowCopy(a); // b — это отдельный объект
b.x = 10;
console.log(a.x); // 1

// Но a.z и b.z указывают на один и тот же массив:
b.z.push(4);
console.log(a.z); // [1, 2, 3, 4]
Если в функцию копирования передан объект Date, надо создавать копию того же типа.

var с = new Date(2014, 1, 1);
var d = shallowCopy(c);
d.setFullYear(2015);
console.log(c.getFullYear()); // 2014

13. Напиши функцию глубокого копирования объектов и массивов.
Она должна делать не только копию переданного объекта/массива, но и копии вложенных них объектов/массивов.
Также, копироваться должны объекты Date

var a = { x: 1, y: 2, z: [1, 2, 3], w: new Date(2014, 1, 1, 12, 0, 0) };
var b = deepCopy(a); // b — это отдельный объект
b.x = 10;
console.log(a.x); // 1

// a.z и b.z указывают на разные массивы:
b.z.push(4);
console.log(a.z); // [1, 2, 3]

// a.w и b.w независимы друг от друга
b.w.setFullYear(2015);
console.log(a.w.getFullYear()); // 2014
